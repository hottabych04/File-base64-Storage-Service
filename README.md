# Тестовое задание для отбора на CaseLab от Росатом
## Условие задания
### Задача:
Необходимо реализовать микросервис, который будет выполнять роль хранилища различных файлов
и их атрибутов.

Микросервис должен предоставлять HTTP API и принимать/отдавать запросы/ответы в формате JSON.

Разработка UI-интерфейса не требуется. Для тестирования можно использовать Postman или аналог.

Должны быть реализованы следующие API-методы:

1. Создание файла.

На вход методу отправляется JSON, включающий в себя файл (в формате base64) и его атрибуты (название - 
title, дата и время отправки - creation_date, краткое описание документа - description), на выходе метод
возвращает id созданного файла.

2. Получение файла.

На вход методу отправляется id файла, на выходе метод возвращает JSON,
включающий в себя файл (в формате base64) и его атрибуты (название - title,
дата и время отправки - creation_date, краткое описание документа -
description)

### Технологический стек

Микросервис должен быть реализован на Java+Spring Boot, но допускается использование и дополнительных
библиотек.

Для хранения данных (и самого файла, и его атрибутов) использовать СУБД PostgreSQL.

Дополнительные требования (их реализовывать необязательно, но если сможешь реализовать какие-то
пункты - будет очень круто, мы это отметим как преимущество):

1. Добавить метод получения списка всех файлов (и их атрибутов). Необходимо реализовать пагинацию и
сортировку по времени создания файлов.
2. Покрыть проект тестами на JUnit.
3. Обернуть микросервис в docker-контейнер (можно в один вместе с БД).

## Автор решения

Бабиченко Илья Станиславович

## Описание реализации

Для решения, помимо перечисленных выше Java+Spring Boot, так же использовались такие библиотеки: Spring
Web (для создания слоя контроллеров и эндпоинтов), Spring Data JPA (для работы с БД и сущностями),
Liquibase (для реализации миграции БД), JUnit 5 (для тестов), AssertJ, Spring Boot Starter Test (для реализации интеграционного 
тестирования), Testcontainers (для создания тестовой БД), Swagger (для удобной проверки функционала). В качестве 
СУБД использовался PostgreSQL как и было указанно в условии.

### База данных

Вся инициализация необходимой структуры в БД полностью автомитизированна при помощи библиотеки миграции Liquibase.
Файлы и скрипты для инициализации и изменения таблиц лежат в директории `src/main/resources/db/changelog`
  * Основной файл с перечисленными скриптами для выполнения называется `db.changelog-master.yaml`
  * Для хранения в БД файлов и их атрибутов создается таблица `file` в стандартной схеме `public`.
  Скрипт инициализации этой таблицы находится в `db.changelog-1.0.sql`.
  * Второй скрипт `db.changelog-2.0.sql` инициализирует 15 сущностей в описанной выше таблице, для 
  упрощения проверки рабоспособности сервиса и прохождения тестов.

### Сервис

Все основные компоненты сервиса расположены в директории `src/main/java/com/hottabych04/app`.
  * В данной директории находится класс `ApplicationRunner` помеченный `@SpringBootApplication`,
  реализующий метод `main`.
  * В пакете `database.entity` хранится класс сущности `File` которая содержит в себе аттрибуты файла и его
  данные. (Было принято решение - аудитинг к данной сущности не применять, так как в приложении отсутствуют
  методы для изменения сущности).
  * В пакете `database.repository` хранится интерфейс `FileRepository<File, Long>` унаследованный от 
  `JpaRepository`. Благодаря чему все методы для запросов в БД инициализируются автоматически при помощи 
  Spring Data JPA.
  * Для работы на слоях выше репозиториев был создан DTO класс `FileDto` лежащий в пакете `dto` и повторяющий
  все поля класса `File`, а класс `PageFileDto` содержит в себе необходимую информацию 
  о странице, имея необходимые поля повторяющиеся в классе `Page<T>`. 
  * Для преобразования `FileDto` и `File` были созданы классы `ReadFileMapper` и `SaveFileMapper` наследованные 
  от написанного интерфейса `Mapper<F, T>` где `F` - From, `T` - To. В них реализован единственный метод 
  `T map(F object)`. Находятся эти классы в пакете `mapper`. Для пеобразования `Page<File>` в `PageFileDto`
  реализован класс `PageFileReadMapper`. 
  * Класс `FileService` представляющий собой слой сервисов находится в пакете `service`. Данный класс 
  выполняет связующую функцию между слоем репозиториев и контроллеров. Выполняет методы 
  для запросов в БД и преобразовывает входные и выходные данные в нужные форматы.
  * Класс `FileController` лежащий в пакете `http.controller` реализует слой контроллеров, и занимается обработкой 
  http запросов. Реализовано три эндпоинта которые отвечают за методы создания, получения по айди и получения 
  всех файлов постранично.
  * В пакете `http.handler` реализован класс `FileExceptionHandler` который отлавливает ошибки связанные с 
  невалидностью отправленных данных в метод `save()` и возвращает соответсвующий статус код.
  * В `src/main/resources/application.yml` указаны параметры для Spring Application.

### Тесты

Все компоненты необходимые для тестов находятся в директории `src/test/java/com/hottabych04/app/integration`.
  * В пакете `annotation` находится аннотация `@IT` которая помечена аннотациями `@SpringBootTest`
  и `@ActiveProfiles("test")`. Данная аннотация нужна для применения к почмеченным классам сразу двух
 перечиленных аннотаций.
  * В директории со всемии остальными компонентами находится абстрактный класс `IntegrationTestBase` который
  инициализирует новый контейнер в докере с БД для тестов, а так же помечен `@IT`. Все интеграционные тесты 
  унаследованы от этого класса.
  * В пакетах `database`, `mapper` и `service` содержатся классы для интеграционного тестирования 
  реализованных методов в исходных классах при помощи `Mock` объектов.
  * Класс `FileRepositoryIT` реализует юнит тесты методов `FileRepository` класса с запросами в тестовую БД.
  Параметры подключения к тестовой БД указаны в `src/test/resources/application-test.yml`, где приставка
  `-test` в названии файла означает применение параметров из этого файла только в случае активации профиля 
  `test`, что и происходит в `@IT`.
  * Классы которые находятся в пакете `http` реализуют интеграционное тестирование исходных классов при 
  помощи `MockMvc`.

### Докеризация

В директории `src/main/docker` находятся фалйлы для развертывания сервиса в Docker.
Так же среди файлов присутствует собранный `file-storage-server.jar` для упрощения развертывания.
  
## Иструкция по запуску приложения

**Для запуска сервиса необходим Docker и плагин docker-compose**

Инструкция:
1. Скачиваем zip-архив репозитория и распаковываем его в необходимое место. Или клонируем репозиторий
   (необходим установленный git в системе):
    ```
    git clone https://github.com/hottabych04/File-base64-Storage-Service.git
    ```

2. Переходим в директорию архива:
    ```
    cd File-base64-Storage-Service/src/main/docker
    ```
   
3. Запускаем инициализацию необходимых контейнеров в Docker:
    ```
    docker-compose up
    ```
   
**Готово!**

Теперь наш сервис доступен на порту 8080, куда можно отправлять http запросы.

## Примеры запросов

Для выполнения запросов можно использовать UI "Swagger", перейдя в браузере по адресу
http://localhost:8080/swagger-ui/index.html

1. Для сохранения файла необходимо отправить PUT запрос по 
адресу http://localhost:8080/api/v1/files/save с телом запроса JSON следующего формата:
```json
{
  "title": "string",
  "description": "string",
  "creationDate": "2024-07-20T06:42:32.401Z",
  "data": "string"
}
```
после чего, в случае успеха, сервис вернет ответ JSON формата с номером `id` новой сущности 
и статусом `201 Created`.

2. Для получения файла по `id` необходимо отправить GET запрос по адресу
http://localhost:8080/api/v1/files/get/{id}, где вместо `{id}` указать `id` файла который вы желаете получить.
В случае успеха, сервер вернет статус код `200 Ok` и ответ JSON следующего формата:
```json
{
  "title": "string",
  "description": "string",
  "creationDate": "2024-07-20T06:44:31.134",
  "data": "string"
}
```

3. Для получения всех файлов постранично, необходимо отправить GET запрос по адресу
   http://localhost:8080/api/v1/files/get/page/{page}, где вместо `{page}` указать номер страницы которую вы желаете получить.
   В случае успеха, сервер вернет статус код `200 Ok` и ответ JSON следующего формата:
```json
{
  "totalElements": 38,
  "totalPages": 8,
  "number": 1,
  "pageSize": 5,
  "numberOfElements": 5,
  "first": false,
  "last": false,
  "empty": false,
  "content": [
    {
      "id": 34,
      "title": "string",
      "description": "string",
      "creationDate": "2024-07-20T07:24:00.239",
      "data": "string"
    },
    {
      "id": 30,
      "title": "string",
      "description": "string",
      "creationDate": "2024-07-20T07:24:00.239",
      "data": "string"
    },
    {
      "id": 29,
      "title": "string",
      "description": "string",
      "creationDate": "2024-07-20T07:24:00.239",
      "data": "string"
    },
    {
      "id": 32,
      "title": "string",
      "description": "string",
      "creationDate": "2024-07-20T07:24:00.239",
      "data": "string"
    },
    {
      "id": 36,
      "title": "string",
      "description": "string",
      "creationDate": "2024-07-20T07:24:00.239",
      "data": "string"
    }
  ]
}
```

В случае неудачного выполнения любого запроса, сервер вернет ответ в виде JSON который сгенерировал стандартный `ResponseEntityExceptionHandler` определенный в Spring Web, 
а для `save` метода обработкой ошибок, возникших в результате отправки невалидного тела запроса, занимается `FileExceptionHandler` в пакете `http.handler`:
```json
{
  "timestamp": "2024-07-20T09:00:03.098+00:00",
  "status": 400,
  "error": "Error",
  "path": "/path"
}
```
